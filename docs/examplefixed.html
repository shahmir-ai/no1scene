<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Thumbnail Scene Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #fff;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .panel {
            width: 280px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border: 1px solid #333;
        }

        .panel::-webkit-scrollbar {
            width: 8px;
        }

        .panel::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .panel::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .scene-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .control-group {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #444;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #4CAF50;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-item {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }

        input[type="file"],
        input[type="color"],
        input[type="range"],
        input[type="number"],
        select {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
        }

        input[type="range"] {
            padding: 0;
        }

        button {
            width: 100%;
            padding: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button.secondary {
            background: #555;
        }

        button.secondary:hover {
            background: #666;
        }

        .bone-controls {
            max-height: 300px;
            overflow-y: auto;
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
        }

        .bone-item {
            margin-bottom: 15px;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 4px;
        }

        .bone-name {
            font-weight: bold;
            margin-bottom: 8px;
            color: #4CAF50;
            font-size: 11px;
        }

        .axis-control {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .axis-label {
            width: 20px;
            font-weight: bold;
            color: #888;
        }

        .axis-control input {
            flex: 1;
            margin-left: 10px;
        }

        .screenshot-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #ff4444;
            padding: 15px 30px;
            font-size: 16px;
            z-index: 100;
        }

        .screenshot-button:hover {
            background: #ff6666;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }

        .preset-buttons button {
            padding: 8px;
            font-size: 11px;
        }

        .preset-buttons button.secondary {
            grid-column: span 1;
        }

        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="panel">
            <div class="control-group">
                <h3>Model</h3>
                <div class="control-item">
                    <input type="file" id="modelUpload" accept=".glb,.gltf">
                    <div class="info-text">Upload Mixamo-rigged GLB/GLTF</div>
                </div>
            </div>

            <div class="control-group">
                <h3>Camera</h3>
                <div class="control-item">
                    <label>Field of View</label>
                    <input type="range" id="fov" min="20" max="120" value="50">
                </div>
                <div class="control-item">
                    <label>Distance</label>
                    <input type="range" id="cameraDistance" min="1" max="20" value="5">
                </div>
                <div class="control-item">
                    <label>Height</label>
                    <input type="range" id="cameraHeight" min="-5" max="5" value="0" step="0.1">
                </div>
                <div class="preset-buttons">
                    <button onclick="setCameraPreset('front')">Front</button>
                    <button onclick="setCameraPreset('side')">Side</button>
                    <button onclick="setCameraPreset('top')">Top</button>
                    <button onclick="setCameraPreset('angle')">3/4 View</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Lighting</h3>
                <div class="control-item">
                    <label>Ambient Light</label>
                    <input type="color" id="ambientColor" value="#404040">
                    <input type="range" id="ambientIntensity" min="0" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-item">
                    <label>Key Light</label>
                    <input type="color" id="keyLightColor" value="#ffffff">
                    <input type="range" id="keyLightIntensity" min="0" max="3" step="0.1" value="1">
                </div>
                <div class="control-item">
                    <label>Fill Light</label>
                    <input type="color" id="fillLightColor" value="#4444ff">
                    <input type="range" id="fillLightIntensity" min="0" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-item">
                    <label>Rim Light</label>
                    <input type="color" id="rimLightColor" value="#ffaa00">
                    <input type="range" id="rimLightIntensity" min="0" max="2" step="0.1" value="0.3">
                </div>
            </div>
        </div>

        <!-- Scene Container -->
        <div class="scene-container">
            <canvas id="canvas"></canvas>
            <button class="screenshot-button" onclick="takeScreenshot()">
                ðŸ“¸ Capture Thumbnail (1280x720)
            </button>
            <div id="loadingIndicator">Loading model...</div>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <div class="control-group">
                <h3>Background</h3>
                <div class="control-item">
                    <label>Background Type</label>
                    <select id="bgType">
                        <option value="color">Solid Color</option>
                        <option value="gradient">Gradient</option>
                        <option value="transparent">Transparent</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>Background Color</label>
                    <input type="color" id="bgColor" value="#1a1a2e">
                </div>
                <div class="control-item">
                    <label>Gradient Top</label>
                    <input type="color" id="bgGradientTop" value="#16213e">
                </div>
                <div class="control-item">
                    <label>Gradient Bottom</label>
                    <input type="color" id="bgGradientBottom" value="#0f3460">
                </div>
            </div>

            <div class="control-group">
                <h3>Pose Controls</h3>
                <div class="control-item">
                    <label>Select Bone</label>
                    <select id="boneSelector">
                        <option value="">-- Select a bone --</option>
                    </select>
                </div>
                <div class="bone-controls" id="boneControls">
                    <div class="info-text">Load a model to see bone controls</div>
                </div>
                <div class="preset-buttons">
                    <button onclick="setPose('tpose')">T-Pose</button>
                    <button onclick="setPose('apose')">A-Pose</button>
                    <button onclick="setPose('standing')">Standing</button>
                    <button onclick="setPose('action')">Action</button>
                    <button onclick="resetPose()" class="secondary">Reset All</button>
                    <button onclick="mirrorPose()" class="secondary">Mirror Lâ†’R</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Model Transform</h3>
                <div class="control-item">
                    <label>Position X</label>
                    <input type="range" id="modelPosX" min="-5" max="5" step="0.1" value="0">
                </div>
                <div class="control-item">
                    <label>Position Y</label>
                    <input type="range" id="modelPosY" min="-5" max="5" step="0.1" value="0">
                </div>
                <div class="control-item">
                    <label>Position Z</label>
                    <input type="range" id="modelPosZ" min="-5" max="5" step="0.1" value="0">
                </div>
                <div class="control-item">
                    <label>Rotation Y</label>
                    <input type="range" id="modelRotY" min="-180" max="180" value="0">
                </div>
                <div class="control-item">
                    <label>Scale</label>
                    <input type="range" id="modelScale" min="0.1" max="3" step="0.1" value="1">
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let ambientLight, keyLight, fillLight, rimLight;
        let currentModel = null;
        let mixer = null;
        let bones = {};
        let originalBoneRotations = {}; // Store original rotations
        let selectedBone = null;

        // Initialize Three.js
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 2, 5);

            // Renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                preserveDrawingBuffer: true,
                alpha: true
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;

            // Lights
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            keyLight = new THREE.DirectionalLight(0xffffff, 1);
            keyLight.position.set(5, 10, 5);
            keyLight.castShadow = true;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.camera.left = -10;
            keyLight.shadow.camera.right = 10;
            keyLight.shadow.camera.top = 10;
            keyLight.shadow.camera.bottom = -10;
            scene.add(keyLight);

            fillLight = new THREE.DirectionalLight(0x4444ff, 0.5);
            fillLight.position.set(-5, 5, 0);
            scene.add(fillLight);

            rimLight = new THREE.DirectionalLight(0xffaa00, 0.3);
            rimLight.position.set(0, 3, -5);
            scene.add(rimLight);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Ground plane for shadows
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.2 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            setupEventListeners();
            animate();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (mixer) mixer.update(0.016);
            renderer.render(scene, camera);
        }

        // Setup event listeners
        function setupEventListeners() {
            // Model upload
            document.getElementById('modelUpload').addEventListener('change', handleModelUpload);

            // Camera controls
            document.getElementById('fov').addEventListener('input', (e) => {
                camera.fov = e.target.value;
                camera.updateProjectionMatrix();
            });

            document.getElementById('cameraDistance').addEventListener('input', (e) => {
                const distance = parseFloat(e.target.value);
                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(distance));
            });

            document.getElementById('cameraHeight').addEventListener('input', (e) => {
                camera.position.y = parseFloat(e.target.value);
            });

            // Lighting controls
            document.getElementById('ambientColor').addEventListener('change', (e) => {
                ambientLight.color.set(e.target.value);
            });

            document.getElementById('ambientIntensity').addEventListener('input', (e) => {
                ambientLight.intensity = parseFloat(e.target.value);
            });

            document.getElementById('keyLightColor').addEventListener('change', (e) => {
                keyLight.color.set(e.target.value);
            });

            document.getElementById('keyLightIntensity').addEventListener('input', (e) => {
                keyLight.intensity = parseFloat(e.target.value);
            });

            document.getElementById('fillLightColor').addEventListener('change', (e) => {
                fillLight.color.set(e.target.value);
            });

            document.getElementById('fillLightIntensity').addEventListener('input', (e) => {
                fillLight.intensity = parseFloat(e.target.value);
            });

            document.getElementById('rimLightColor').addEventListener('change', (e) => {
                rimLight.color.set(e.target.value);
            });

            document.getElementById('rimLightIntensity').addEventListener('input', (e) => {
                rimLight.intensity = parseFloat(e.target.value);
            });

            // Background controls
            document.getElementById('bgType').addEventListener('change', updateBackground);
            document.getElementById('bgColor').addEventListener('change', updateBackground);
            document.getElementById('bgGradientTop').addEventListener('change', updateBackground);
            document.getElementById('bgGradientBottom').addEventListener('change', updateBackground);

            // Model transform controls
            document.getElementById('modelPosX').addEventListener('input', updateModelTransform);
            document.getElementById('modelPosY').addEventListener('input', updateModelTransform);
            document.getElementById('modelPosZ').addEventListener('input', updateModelTransform);
            document.getElementById('modelRotY').addEventListener('input', updateModelTransform);
            document.getElementById('modelScale').addEventListener('input', updateModelTransform);

            // Bone selector
            document.getElementById('boneSelector').addEventListener('change', (e) => {
                selectBone(e.target.value);
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Handle model upload
        function handleModelUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('loadingIndicator').style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(e) {
                const loader = new THREE.GLTFLoader();
                loader.parse(e.target.result, '', (gltf) => {
                    loadModel(gltf);
                    document.getElementById('loadingIndicator').style.display = 'none';
                }, (error) => {
                    console.error('Error loading model:', error);
                    document.getElementById('loadingIndicator').style.display = 'none';
                    alert('Error loading model. Please ensure it\'s a valid GLB/GLTF file.');
                });
            };
            reader.readAsArrayBuffer(file);
        }

        // Load model into scene
        function loadModel(gltf) {
            // Remove existing model
            if (currentModel) {
                scene.remove(currentModel);
            }

            currentModel = gltf.scene;
            scene.add(currentModel);

            // Center and scale model
            const box = new THREE.Box3().setFromObject(currentModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 2 / maxDim;
            
            currentModel.scale.multiplyScalar(scale);
            currentModel.position.sub(center.multiplyScalar(scale));
            currentModel.position.y = 0;

            // Enable shadows
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Setup animation mixer
            if (gltf.animations && gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(currentModel);
            }

            // Find and store bones
            findBones();
        }

        // Find all bones in the model
        function findBones() {
            bones = {};
            originalBoneRotations = {};
            const boneSelector = document.getElementById('boneSelector');
            boneSelector.innerHTML = '<option value="">-- Select a bone --</option>';

            currentModel.traverse((child) => {
                if (child.isBone) {
                    bones[child.name] = child;
                    // Store the original rotation
                    originalBoneRotations[child.name] = {
                        x: child.rotation.x,
                        y: child.rotation.y,
                        z: child.rotation.z
                    };
                    const option = document.createElement('option');
                    option.value = child.name;
                    option.textContent = child.name;
                    boneSelector.appendChild(option);
                }
            });

            console.log('Found bones:', Object.keys(bones));
            console.log('Original rotations:', originalBoneRotations);
            updateBoneControlsList();
        }

            // Update bone controls list
        function updateBoneControlsList() {
            const container = document.getElementById('boneControls');
            
            if (Object.keys(bones).length === 0) {
                container.innerHTML = '<div class="info-text">No bones found in model</div>';
                return;
            }

            container.innerHTML = '';
            
            // Show controls for major bones - check both standard and Mixamo naming
            const majorBones = [
                // Mixamo naming convention
                'mixamorigHips', 'mixamorigSpine', 'mixamorigSpine1', 'mixamorigSpine2', 
                'mixamorigNeck', 'mixamorigHead',
                'mixamorigLeftShoulder', 'mixamorigLeftArm', 'mixamorigLeftForeArm', 'mixamorigLeftHand',
                'mixamorigRightShoulder', 'mixamorigRightArm', 'mixamorigRightForeArm', 'mixamorigRightHand',
                'mixamorigLeftUpLeg', 'mixamorigLeftLeg', 'mixamorigLeftFoot',
                'mixamorigRightUpLeg', 'mixamorigRightLeg', 'mixamorigRightFoot',
                // Alternative naming
                'Hips', 'Spine', 'Spine1', 'Spine2', 'Neck', 'Head', 
                'LeftShoulder', 'LeftArm', 'LeftForeArm', 'LeftHand',
                'RightShoulder', 'RightArm', 'RightForeArm', 'RightHand',
                'LeftUpLeg', 'LeftLeg', 'LeftFoot', 
                'RightUpLeg', 'RightLeg', 'RightFoot',
                // Unity/other naming
                'LeftUpperArm', 'RightUpperArm', 'LeftLowerArm', 'RightLowerArm',
                'LeftUpperLeg', 'RightUpperLeg', 'LeftLowerLeg', 'RightLowerLeg'
            ];
            
            // Create controls for existing bones
            const addedBones = new Set();
            majorBones.forEach(boneName => {
                if (bones[boneName] && !addedBones.has(boneName)) {
                    createBoneControl(boneName, bones[boneName]);
                    addedBones.add(boneName);
                }
            });
        }

        // Create bone control UI
        function createBoneControl(name, bone) {
            const container = document.getElementById('boneControls');
            
            // Get original rotation for this bone
            const origRot = originalBoneRotations[name] || {x: 0, y: 0, z: 0};
            
            // Determine appropriate rotation ranges based on bone type
            let xRange = [-90, 90];
            let yRange = [-90, 90];
            let zRange = [-90, 90];
            
            // Arms should have wider Z rotation range
            if (name.includes('Arm') && !name.includes('Fore')) {
                zRange = [-180, 180];
            }
            // Forearms mainly rotate on Y axis
            if (name.includes('ForeArm')) {
                yRange = [-135, 135];
            }
            // Legs have limited ranges
            if (name.includes('Leg') || name.includes('UpLeg')) {
                xRange = [-90, 45];
                yRange = [-45, 45];
                zRange = [-45, 45];
            }
            // Spine has moderate ranges
            if (name.includes('Spine') || name.includes('Hips')) {
                xRange = [-45, 45];
                yRange = [-60, 60];
                zRange = [-30, 30];
            }
            // Head and neck
            if (name.includes('Head') || name.includes('Neck')) {
                xRange = [-60, 60];
                yRange = [-90, 90];
                zRange = [-45, 45];
            }
            
            const boneItem = document.createElement('div');
            boneItem.className = 'bone-item';
            
            // Current rotation in degrees relative to original
            const currentX = THREE.MathUtils.radToDeg(bone.rotation.x - origRot.x);
            const currentY = THREE.MathUtils.radToDeg(bone.rotation.y - origRot.y);
            const currentZ = THREE.MathUtils.radToDeg(bone.rotation.z - origRot.z);
            
            boneItem.innerHTML = `
                <div class="bone-name">${name}</div>
                <div class="axis-control">
                    <span class="axis-label">X:</span>
                    <input type="range" min="${xRange[0]}" max="${xRange[1]}" value="${currentX}" 
                           data-bone="${name}" data-axis="x">
                </div>
                <div class="axis-control">
                    <span class="axis-label">Y:</span>
                    <input type="range" min="${yRange[0]}" max="${yRange[1]}" value="${currentY}" 
                           data-bone="${name}" data-axis="y">
                </div>
                <div class="axis-control">
                    <span class="axis-label">Z:</span>
                    <input type="range" min="${zRange[0]}" max="${zRange[1]}" value="${currentZ}" 
                           data-bone="${name}" data-axis="z">
                </div>
            `;
            
            container.appendChild(boneItem);
            
            // Add event listeners - apply rotation relative to original
            boneItem.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', (e) => {
                    const boneName = e.target.dataset.bone;
                    const axis = e.target.dataset.axis;
                    const value = THREE.MathUtils.degToRad(parseFloat(e.target.value));
                    const orig = originalBoneRotations[boneName] || {x: 0, y: 0, z: 0};
                    
                    if (bones[boneName]) {
                        // Apply rotation relative to original
                        bones[boneName].rotation[axis] = orig[axis] + value;
                    }
                });
            });
        }

        // Select bone for detailed control
        function selectBone(boneName) {
            if (!boneName || !bones[boneName]) {
                selectedBone = null;
                return;
            }
            selectedBone = bones[boneName];
        }

        // Set camera preset
        function setCameraPreset(preset) {
            switch(preset) {
                case 'front':
                    camera.position.set(0, 1, 5);
                    break;
                case 'side':
                    camera.position.set(5, 1, 0);
                    break;
                case 'top':
                    camera.position.set(0, 8, 0);
                    break;
                case 'angle':
                    camera.position.set(3, 2, 3);
                    break;
            }
            controls.target.set(0, 0, 0);
            controls.update();
        }

        // Set pose preset
        function setPose(poseType) {
            if (!bones) return;

            // Reset all bones to their ORIGINAL rotations first
            Object.entries(bones).forEach(([name, bone]) => {
                if (originalBoneRotations[name]) {
                    bone.rotation.x = originalBoneRotations[name].x;
                    bone.rotation.y = originalBoneRotations[name].y;
                    bone.rotation.z = originalBoneRotations[name].z;
                }
            });

            // Helper function to find bone with either naming convention
            const findBone = (names) => {
                for (let name of names) {
                    if (bones[name]) return bones[name];
                }
                return null;
            };

            // Helper to ADD rotation in degrees to existing rotation
            const addRotationDeg = (bone, x, y, z) => {
                if (bone) {
                    const boneName = Object.keys(bones).find(key => bones[key] === bone);
                    const orig = originalBoneRotations[boneName] || {x: 0, y: 0, z: 0};
                    
                    if (x !== undefined) bone.rotation.x = orig.x + THREE.MathUtils.degToRad(x);
                    if (y !== undefined) bone.rotation.y = orig.y + THREE.MathUtils.degToRad(y);
                    if (z !== undefined) bone.rotation.z = orig.z + THREE.MathUtils.degToRad(z);
                }
            };

            switch(poseType) {
                case 'tpose':
                    // T-Pose - ONLY move arms, nothing else
                    const leftArmT = findBone(['mixamorigLeftArm', 'LeftArm', 'LeftUpperArm', 'Left_Arm', 'left_arm']);
                    const rightArmT = findBone(['mixamorigRightArm', 'RightArm', 'RightUpperArm', 'Right_Arm', 'right_arm']);
                    
                    addRotationDeg(leftArmT, 0, 0, 90);
                    addRotationDeg(rightArmT, 0, 0, -90);
                    break;
                    
                case 'apose':
                    // A-Pose - ONLY move arms at 45 degrees
                    const leftArmA = findBone(['mixamorigLeftArm', 'LeftArm', 'LeftUpperArm', 'Left_Arm', 'left_arm']);
                    const rightArmA = findBone(['mixamorigRightArm', 'RightArm', 'RightUpperArm', 'Right_Arm', 'right_arm']);
                    
                    addRotationDeg(leftArmA, 0, 0, 45);
                    addRotationDeg(rightArmA, 0, 0, -45);
                    break;
                    
                case 'standing':
                    // Just reset to original - don't move anything
                    // Original rotations already applied at the start
                    break;
                    
                case 'action':
                    // Very simple action - ONLY arms, no legs!
                    const leftArmAction = findBone(['mixamorigLeftArm', 'LeftArm', 'LeftUpperArm', 'Left_Arm', 'left_arm']);
                    const rightArmAction = findBone(['mixamorigRightArm', 'RightArm', 'RightUpperArm', 'Right_Arm', 'right_arm']);
                    const leftForeArm = findBone(['mixamorigLeftForeArm', 'LeftForeArm', 'LeftLowerArm', 'Left_ForeArm', 'left_forearm']);
                    const rightForeArm = findBone(['mixamorigRightForeArm', 'RightForeArm', 'RightLowerArm', 'Right_ForeArm', 'right_forearm']);
                    
                    addRotationDeg(leftArmAction, -20, 0, 30);
                    addRotationDeg(rightArmAction, 10, 0, -15);
                    addRotationDeg(leftForeArm, 0, -30, 0);
                    addRotationDeg(rightForeArm, 0, 20, 0);
                    break;
            }

            // Update UI sliders
            updateBoneSliders();
        }

        // Reset all bone rotations to original
        function resetPose() {
            if (!bones || !originalBoneRotations) return;
            
            Object.entries(bones).forEach(([name, bone]) => {
                if (originalBoneRotations[name]) {
                    bone.rotation.x = originalBoneRotations[name].x;
                    bone.rotation.y = originalBoneRotations[name].y;
                    bone.rotation.z = originalBoneRotations[name].z;
                } else {
                    bone.rotation.set(0, 0, 0);
                }
            });
            
            console.log('Reset to original rotations');
            updateBoneSliders();
        }

        // Mirror pose from left to right
        function mirrorPose() {
            if (!bones || !originalBoneRotations) return;
            
            const mirrorPairs = [
                ['mixamorigLeftArm', 'mixamorigRightArm'],
                ['mixamorigLeftForeArm', 'mixamorigRightForeArm'],
                ['mixamorigLeftHand', 'mixamorigRightHand'],
                ['mixamorigLeftShoulder', 'mixamorigRightShoulder'],
                ['mixamorigLeftUpLeg', 'mixamorigRightUpLeg'],
                ['mixamorigLeftLeg', 'mixamorigRightLeg'],
                ['mixamorigLeftFoot', 'mixamorigRightFoot'],
                ['LeftArm', 'RightArm'],
                ['LeftForeArm', 'RightForeArm'],
                ['LeftHand', 'RightHand'],
                ['LeftShoulder', 'RightShoulder'],
                ['LeftUpLeg', 'RightUpLeg'],
                ['LeftLeg', 'RightLeg'],
                ['LeftFoot', 'RightFoot']
            ];
            
            mirrorPairs.forEach(([leftName, rightName]) => {
                if (bones[leftName] && bones[rightName]) {
                    const leftOrig = originalBoneRotations[leftName] || {x: 0, y: 0, z: 0};
                    const rightOrig = originalBoneRotations[rightName] || {x: 0, y: 0, z: 0};
                    
                    // Get left bone's rotation relative to its original
                    const leftRelX = bones[leftName].rotation.x - leftOrig.x;
                    const leftRelY = bones[leftName].rotation.y - leftOrig.y;
                    const leftRelZ = bones[leftName].rotation.z - leftOrig.z;
                    
                    // Apply mirrored rotation to right bone relative to its original
                    bones[rightName].rotation.x = rightOrig.x + leftRelX;
                    bones[rightName].rotation.y = rightOrig.y - leftRelY;  // Mirror Y
                    bones[rightName].rotation.z = rightOrig.z - leftRelZ;  // Mirror Z
                }
            });
            
            updateBoneSliders();
        }

        // Update bone sliders to match current rotations
        function updateBoneSliders() {
            Object.entries(bones).forEach(([name, bone]) => {
                const xSlider = document.querySelector(`input[data-bone="${name}"][data-axis="x"]`);
                const ySlider = document.querySelector(`input[data-bone="${name}"][data-axis="y"]`);
                const zSlider = document.querySelector(`input[data-bone="${name}"][data-axis="z"]`);
                
                // Get original rotation for this bone
                const origRot = originalBoneRotations[name] || {x: 0, y: 0, z: 0};
                
                // Calculate rotation relative to original
                const xDeg = THREE.MathUtils.radToDeg(bone.rotation.x - origRot.x);
                const yDeg = THREE.MathUtils.radToDeg(bone.rotation.y - origRot.y);
                const zDeg = THREE.MathUtils.radToDeg(bone.rotation.z - origRot.z);
                
                if (xSlider) {
                    // Clamp to slider's range
                    const min = parseFloat(xSlider.min);
                    const max = parseFloat(xSlider.max);
                    xSlider.value = Math.max(min, Math.min(max, xDeg));
                }
                if (ySlider) {
                    const min = parseFloat(ySlider.min);
                    const max = parseFloat(ySlider.max);
                    ySlider.value = Math.max(min, Math.min(max, yDeg));
                }
                if (zSlider) {
                    const min = parseFloat(zSlider.min);
                    const max = parseFloat(zSlider.max);
                    zSlider.value = Math.max(min, Math.min(max, zDeg));
                }
            });
        }

        // Update model transform
        function updateModelTransform() {
            if (!currentModel) return;
            
            const posX = parseFloat(document.getElementById('modelPosX').value);
            const posY = parseFloat(document.getElementById('modelPosY').value);
            const posZ = parseFloat(document.getElementById('modelPosZ').value);
            const rotY = THREE.MathUtils.degToRad(parseFloat(document.getElementById('modelRotY').value));
            const scale = parseFloat(document.getElementById('modelScale').value);
            
            currentModel.position.set(posX, posY, posZ);
            currentModel.rotation.y = rotY;
            currentModel.scale.setScalar(scale);
        }

        // Update background
        function updateBackground() {
            const bgType = document.getElementById('bgType').value;
            const bgColor = document.getElementById('bgColor').value;
            
            if (bgType === 'color') {
                scene.background = new THREE.Color(bgColor);
            } else if (bgType === 'gradient') {
                const topColor = document.getElementById('bgGradientTop').value;
                const bottomColor = document.getElementById('bgGradientBottom').value;
                
                // Create gradient texture
                const canvas = document.createElement('canvas');
                canvas.width = 2;
                canvas.height = 512;
                const context = canvas.getContext('2d');
                const gradient = context.createLinearGradient(0, 0, 0, 512);
                gradient.addColorStop(0, topColor);
                gradient.addColorStop(1, bottomColor);
                context.fillStyle = gradient;
                context.fillRect(0, 0, 2, 512);
                
                const texture = new THREE.CanvasTexture(canvas);
                scene.background = texture;
            } else if (bgType === 'transparent') {
                scene.background = null;
            }
        }

        // Take screenshot
        function takeScreenshot() {
            // Store current size
            const currentWidth = renderer.domElement.width;
            const currentHeight = renderer.domElement.height;
            const currentAspect = camera.aspect;

            // Set to YouTube thumbnail size
            const targetWidth = 1280;
            const targetHeight = 720;
            
            renderer.setSize(targetWidth, targetHeight);
            camera.aspect = targetWidth / targetHeight;
            camera.updateProjectionMatrix();
            
            // Render frame
            renderer.render(scene, camera);
            
            // Get image
            const dataURL = renderer.domElement.toDataURL('image/png');
            
            // Create download link
            const link = document.createElement('a');
            link.download = `thumbnail_${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            // Restore original size
            renderer.setSize(currentWidth, currentHeight);
            camera.aspect = currentAspect;
            camera.updateProjectionMatrix();
        }

        // Handle window resize
        function onWindowResize() {
            const canvas = document.getElementById('canvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        // Initialize on load
        init();
        updateBackground();
    </script>
</body>
</html>